<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Fireworks</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #video {
            display: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            cursor: pointer;
            z-index: 10;
        }

        #start-screen h1 {
            font-size: 3rem;
            color: #fff;
            margin-bottom: 1rem;
        }

        #start-screen p {
            font-size: 1.2rem;
            color: #888;
        }

        #start-screen.hidden {
            display: none;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            color: #fff;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #ui-overlay.visible {
            opacity: 1;
        }

        #ui-overlay h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        #ui-overlay .status {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        #ui-overlay .hint {
            font-size: 0.8rem;
            color: #888;
            margin-top: 10px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.waiting {
            background: #666;
        }

        .status-indicator.charging {
            background: #ff6b6b;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff6b6b;
            padding: 20px 30px;
            border-radius: 10px;
            color: #fff;
            text-align: center;
            z-index: 20;
            display: none;
        }

        #error-message.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <audio id="background-music" src="background.mp3" loop preload="auto"></audio>
        
        <div id="start-screen">
            <h1>ðŸŽ† Gesture Fireworks</h1>
            <p>Click anywhere to start</p>
        </div>

        <div id="ui-overlay">
            <h2>ðŸŽ† Gesture Fireworks</h2>
            <div class="status" id="left-hand-status">
                <span class="status-indicator waiting"></span>
                Left hand: Waiting
            </div>
            <div class="status" id="right-hand-status">
                <span class="status-indicator waiting"></span>
                Right hand: Waiting
            </div>
            <div class="hint">Pinch and release to launch fireworks</div>
        </div>

        <div id="error-message">
            <p>Camera access needed for hand tracking</p>
            <p style="margin-top: 10px; font-size: 0.9rem; color: #888;">Please allow camera access and refresh</p>
        </div>
    </div>

    <script>
        // ============================================
        // CAMERA MANAGER
        // ============================================
        class CameraManager {
            constructor(videoElement) {
                this.video = videoElement;
                this.stream = null;
            }

            async start() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'user',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    this.video.srcObject = this.stream;
                    await this.video.play();
                    return true;
                } catch (error) {
                    console.error('Camera error:', error);
                    return false;
                }
            }

            getVideoDimensions() {
                return {
                    width: this.video.videoWidth,
                    height: this.video.videoHeight
                };
            }
        }

        // ============================================
        // HAND TRACKER
        // ============================================
        class HandTracker {
            constructor() {
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                    }
                });

                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,  // Lowered for better detection
                    minTrackingConfidence: 0.4    // Lowered for smoother tracking
                });

                this.latestResults = null;
                this.onResultsCallback = null;
            }

            async initialize() {
                return new Promise((resolve) => {
                    this.hands.onResults((results) => {
                        this.latestResults = results;
                        if (this.onResultsCallback) {
                            this.onResultsCallback(results);
                        }
                    });
                    this.hands.initialize().then(() => {
                        console.log('MediaPipe Hands initialized');
                        resolve();
                    });
                });
            }

            async detectHands(video) {
                await this.hands.send({ image: video });
            }

            onResults(callback) {
                this.onResultsCallback = callback;
            }
        }

        // ============================================
        // RENDERER
        // ============================================
        class Renderer {
            // Hand landmark connections for drawing skeleton
            static HAND_CONNECTIONS = [
                [0, 1], [1, 2], [2, 3], [3, 4],           // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8],           // Index
                [0, 9], [9, 10], [10, 11], [11, 12],      // Middle
                [0, 13], [13, 14], [14, 15], [15, 16],    // Ring
                [0, 17], [17, 18], [18, 19], [19, 20],    // Pinky
                [5, 9], [9, 13], [13, 17]                  // Palm
            ];

            constructor(canvas, video) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.video = video;
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawVideo() {
                const { width, height } = this.canvas;
                const videoAspect = this.video.videoWidth / this.video.videoHeight;
                const canvasAspect = width / height;

                let drawWidth, drawHeight, offsetX, offsetY;

                if (canvasAspect > videoAspect) {
                    drawWidth = width;
                    drawHeight = width / videoAspect;
                    offsetX = 0;
                    offsetY = (height - drawHeight) / 2;
                } else {
                    drawHeight = height;
                    drawWidth = height * videoAspect;
                    offsetX = (width - drawWidth) / 2;
                    offsetY = 0;
                }

                // Save context state
                this.ctx.save();
                
                // Mirror the video horizontally
                this.ctx.translate(width, 0);
                this.ctx.scale(-1, 1);

                // Draw dimmed video
                this.ctx.globalAlpha = 0.7;
                this.ctx.drawImage(this.video, offsetX, offsetY, drawWidth, drawHeight);
                this.ctx.globalAlpha = 1.0;

                // Restore context
                this.ctx.restore();

                // Store video bounds for coordinate conversion
                this.videoBounds = { offsetX, offsetY, drawWidth, drawHeight };
            }

            convertLandmarkToCanvas(landmark) {
                if (!this.videoBounds) return { x: 0, y: 0 };
                
                const { offsetX, offsetY, drawWidth, drawHeight } = this.videoBounds;
                
                // Mirror X coordinate (since video is mirrored)
                const x = this.canvas.width - (offsetX + landmark.x * drawWidth);
                const y = offsetY + landmark.y * drawHeight;
                
                return { x, y };
            }

            drawHandSkeleton(landmarks, isLeftHand, chargePercent = 0) {
                const baseColor = isLeftHand ? '#ff6b6b' : '#4ecdc4';
                const glowIntensity = chargePercent / 100;

                // Draw connections
                this.ctx.strokeStyle = baseColor;
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';

                // Add glow effect
                if (glowIntensity > 0) {
                    this.ctx.shadowColor = baseColor;
                    this.ctx.shadowBlur = 10 + glowIntensity * 20;
                }

                for (const [start, end] of Renderer.HAND_CONNECTIONS) {
                    const startPoint = this.convertLandmarkToCanvas(landmarks[start]);
                    const endPoint = this.convertLandmarkToCanvas(landmarks[end]);

                    this.ctx.beginPath();
                    this.ctx.moveTo(startPoint.x, startPoint.y);
                    this.ctx.lineTo(endPoint.x, endPoint.y);
                    this.ctx.stroke();
                }

                // Draw landmarks
                for (let i = 0; i < landmarks.length; i++) {
                    const point = this.convertLandmarkToCanvas(landmarks[i]);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = baseColor;
                    this.ctx.fill();
                }

                // Reset shadow
                this.ctx.shadowBlur = 0;
            }

            drawPinchIndicator(thumbTip, indexTip, isCharging) {
                const thumb = this.convertLandmarkToCanvas(thumbTip);
                const index = this.convertLandmarkToCanvas(indexTip);

                // Draw circles around thumb and index
                const color = isCharging ? '#ffd93d' : '#ffffff';
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = isCharging ? 15 : 5;

                // Thumb circle
                this.ctx.beginPath();
                this.ctx.arc(thumb.x, thumb.y, 15, 0, Math.PI * 2);
                this.ctx.stroke();

                // Index circle
                this.ctx.beginPath();
                this.ctx.arc(index.x, index.y, 15, 0, Math.PI * 2);
                this.ctx.stroke();

                // Line between them when charging
                if (isCharging) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(thumb.x, thumb.y);
                    this.ctx.lineTo(index.x, index.y);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
            }

            drawParticles(particleSystem) {
                particleSystem.draw(this.ctx);
            }

            drawHint(message) {
                const x = this.canvas.width / 2;
                const y = this.canvas.height / 2 + 100;

                this.ctx.save();
                this.ctx.font = '24px -apple-system, BlinkMacSystemFont, sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                
                // Pulsing animation
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 300);
                this.ctx.globalAlpha = pulse;
                
                this.ctx.fillText(message, x, y);
                this.ctx.restore();
            }

            drawDebugInfo(handsData) {
                if (!handsData || !handsData.multiHandLandmarks) return;
                
                this.ctx.save();
                this.ctx.font = '14px monospace';
                this.ctx.fillStyle = '#fff';
                
                let y = this.canvas.height - 60;
                for (let i = 0; i < handsData.multiHandLandmarks.length; i++) {
                    const handedness = handsData.multiHandedness[i];
                    const landmarks = handsData.multiHandLandmarks[i];
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const dx = thumbTip.x - indexTip.x;
                    const dy = thumbTip.y - indexTip.y;
                    const dist = Math.sqrt(dx*dx + dy*dy).toFixed(3);
                    
                    const info = `Hand ${i}: ${handedness.label} (${(handedness.score * 100).toFixed(0)}%) | Pinch: ${dist}`;
                    this.ctx.fillText(info, 20, y);
                    y += 20;
                }
                this.ctx.restore();
            }
        }

        // ============================================
        // PARTICLE SYSTEM (Enhanced with trails, sparkles, color transitions)
        // ============================================
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.trails = [];
                this.sparkles = [];
                this.gravity = 0.08;
                this.maxParticles = 2000;

                // Vibrant color palettes with multiple hues
                this.palettes = [
                    // Golden Celebration
                    ['#ffd700', '#ffaa00', '#ff6600', '#ff3300', '#ffffff'],
                    // Electric Blue
                    ['#00ffff', '#00bfff', '#1e90ff', '#4169e1', '#ffffff'],
                    // Pink Paradise
                    ['#ff1493', '#ff69b4', '#ff00ff', '#da70d6', '#ffffff'],
                    // Green Aurora
                    ['#00ff00', '#32cd32', '#7fff00', '#adff2f', '#ffffff'],
                    // Purple Galaxy
                    ['#9400d3', '#8a2be2', '#9932cc', '#ba55d3', '#ffffff'],
                    // Rainbow Burst
                    ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'],
                    // Fire Storm
                    ['#ff4500', '#ff6347', '#ff7f50', '#ffa500', '#ffd700', '#ffffff'],
                    // Ice Crystal
                    ['#e0ffff', '#b0e0e6', '#87ceeb', '#00ced1', '#ffffff'],
                ];
            }

            // Convert hex to RGB for color manipulation
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            // Create color string with alpha
            rgbaString(rgb, alpha) {
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }

            createFirework(x, y, charge) {
                const palette = this.palettes[Math.floor(Math.random() * this.palettes.length)];
                
                // Main burst particles
                const mainCount = Math.floor(200 + charge * 200);
                const baseSpeed = 12 + charge * 15;
                
                for (let i = 0; i < mainCount; i++) {
                    if (this.particles.length >= this.maxParticles) break;

                    const angle = (Math.PI * 2 * i) / mainCount + (Math.random() - 0.5) * 1.2;
                    const speed = baseSpeed * (0.3 + Math.random() * 0.7);
                    const colorHex = palette[Math.floor(Math.random() * palette.length)];
                    const colorRgb = this.hexToRgb(colorHex);

                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        colorRgb: colorRgb,
                        colorHex: colorHex,
                        size: 5 + Math.random() * 8,
                        initialSize: 5 + Math.random() * 8,
                        life: 1,
                        decay: 0.006 + Math.random() * 0.008,
                        gravity: this.gravity * (0.5 + Math.random() * 0.5),
                        flicker: Math.random() > 0.7, // 30% of particles flicker
                        trail: Math.random() > 0.5,   // 50% leave trails
                        type: 'main'
                    });
                }

                // Secondary sparkles (smaller, faster decay)
                const sparkleCount = Math.floor(100 + charge * 100);
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (baseSpeed * 0.5) * (0.5 + Math.random() * 0.5);
                    const colorHex = '#ffffff'; // White sparkles
                    const colorRgb = this.hexToRgb(colorHex);

                    this.sparkles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        colorRgb: colorRgb,
                        size: 2 + Math.random() * 3,
                        life: 1,
                        decay: 0.02 + Math.random() * 0.03,
                        gravity: this.gravity * 0.3
                    });
                }

                // Glitter ring (outer ring of bright particles)
                const ringCount = Math.floor(50 + charge * 50);
                const ringSpeed = baseSpeed * 1.3;
                for (let i = 0; i < ringCount; i++) {
                    const angle = (Math.PI * 2 * i) / ringCount;
                    const colorHex = palette[Math.floor(Math.random() * palette.length)];
                    const colorRgb = this.hexToRgb(colorHex);

                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * ringSpeed,
                        vy: Math.sin(angle) * ringSpeed,
                        colorRgb: colorRgb,
                        colorHex: colorHex,
                        size: 3 + Math.random() * 4,
                        initialSize: 3 + Math.random() * 4,
                        life: 1,
                        decay: 0.015 + Math.random() * 0.01,
                        gravity: this.gravity * 0.3,
                        flicker: true,
                        trail: false,
                        type: 'ring'
                    });
                }
            }

            update() {
                // Update main particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Add trail before moving
                    if (p.trail && p.life > 0.3 && Math.random() > 0.5) {
                        this.trails.push({
                            x: p.x,
                            y: p.y,
                            colorRgb: p.colorRgb,
                            size: p.size * 0.5,
                            life: 0.5,
                            decay: 0.05
                        });
                    }

                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;

                    // Apply drag
                    p.vx *= 0.985;
                    p.vy *= 0.985;

                    // Decrease life
                    p.life -= p.decay;
                    
                    // Size shrinks with life
                    p.size = p.initialSize * (0.3 + p.life * 0.7);

                    // Remove dead particles
                    if (p.life <= 0 || p.size < 0.3) {
                        this.particles.splice(i, 1);
                    }
                }

                // Update sparkles
                for (let i = this.sparkles.length - 1; i >= 0; i--) {
                    const s = this.sparkles[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += s.gravity;
                    s.vx *= 0.95;
                    s.vy *= 0.95;
                    s.life -= s.decay;

                    if (s.life <= 0) {
                        this.sparkles.splice(i, 1);
                    }
                }

                // Update trails
                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const t = this.trails[i];
                    t.life -= t.decay;
                    t.size *= 0.9;

                    if (t.life <= 0 || t.size < 0.2) {
                        this.trails.splice(i, 1);
                    }
                }
            }

            draw(ctx) {
                // Use additive blending for glow effect
                ctx.globalCompositeOperation = 'lighter';

                // Draw trails first (behind particles)
                for (const t of this.trails) {
                    const alpha = t.life * 0.6;
                    ctx.fillStyle = this.rgbaString(t.colorRgb, alpha);
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main particles with glow
                ctx.save();
                for (const p of this.particles) {
                    let alpha = p.life;
                    
                    // Flicker effect
                    if (p.flicker) {
                        alpha *= 0.7 + Math.random() * 0.3;
                    }

                    // Outer glow
                    const gradient = ctx.createRadialGradient(
                        p.x, p.y, 0,
                        p.x, p.y, p.size * 2
                    );
                    gradient.addColorStop(0, this.rgbaString(p.colorRgb, alpha));
                    gradient.addColorStop(0.4, this.rgbaString(p.colorRgb, alpha * 0.6));
                    gradient.addColorStop(1, this.rgbaString(p.colorRgb, 0));

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Bright core
                    ctx.fillStyle = this.rgbaString({r: 255, g: 255, b: 255}, alpha * 0.8);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // Draw sparkles
                for (const s of this.sparkles) {
                    const alpha = s.life;
                    ctx.fillStyle = this.rgbaString(s.colorRgb, alpha);
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            }

            clear() {
                this.particles = [];
                this.trails = [];
                this.sparkles = [];
            }
        }

        // ============================================
        // AUDIO MANAGER (Synthesized sounds)
        // ============================================
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
                this.chargeSources = new Map(); // Track charging sounds per hand
            }

            async initialize() {
                if (this.initialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                    console.log('Audio initialized');
                    
                    // Start background music
                    this.backgroundMusic = document.getElementById('background-music');
                    if (this.backgroundMusic) {
                        this.backgroundMusic.volume = 0.3; // 30% volume
                        this.backgroundMusic.play().catch(e => console.log('Music autoplay blocked:', e));
                    }
                } catch (error) {
                    console.warn('Audio not available:', error);
                }
            }

            playCharge(handId) {
                if (!this.audioContext || this.chargeSources.has(handId)) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                oscillator.frequency.linearRampToValueAtTime(300, this.audioContext.currentTime + 2);

                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.1);

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.start();

                this.chargeSources.set(handId, { oscillator, gainNode });
            }

            stopCharge(handId) {
                const source = this.chargeSources.get(handId);
                if (source) {
                    source.gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.1);
                    setTimeout(() => {
                        source.oscillator.stop();
                    }, 150);
                    this.chargeSources.delete(handId);
                }
            }

            updateChargeIntensity(handId, charge) {
                const source = this.chargeSources.get(handId);
                if (source) {
                    // Increase volume and pitch with charge
                    source.gainNode.gain.setValueAtTime(0.1 + charge * 0.2, this.audioContext.currentTime);
                    source.oscillator.frequency.setValueAtTime(100 + charge * 300, this.audioContext.currentTime);
                }
            }

            playExplosion(intensity = 1) {
                if (!this.audioContext) return;

                // Create noise burst
                const bufferSize = this.audioContext.sampleRate * 0.3;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                }

                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;

                // Filter for more "pop" sound
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000 + intensity * 2000, this.audioContext.currentTime);
                filter.frequency.linearRampToValueAtTime(200, this.audioContext.currentTime + 0.3);

                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0.3 * intensity, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                noise.start();

                // Add a "sparkle" high frequency
                const sparkle = this.audioContext.createOscillator();
                sparkle.type = 'sine';
                sparkle.frequency.setValueAtTime(2000 + Math.random() * 1000, this.audioContext.currentTime);
                sparkle.frequency.linearRampToValueAtTime(500, this.audioContext.currentTime + 0.2);

                const sparkleGain = this.audioContext.createGain();
                sparkleGain.gain.setValueAtTime(0.1 * intensity, this.audioContext.currentTime);
                sparkleGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.2);

                sparkle.connect(sparkleGain);
                sparkleGain.connect(this.audioContext.destination);

                sparkle.start();
                sparkle.stop(this.audioContext.currentTime + 0.3);
            }
        }

        // ============================================
        // GESTURE DETECTOR
        // ============================================
        class GestureDetector {
            constructor() {
                this.PINCH_THRESHOLD = 0.10; // Normalized distance (increased for better detection)
                this.CHARGE_RATE = 0.025;    // Charge per frame (faster charging)
                this.MIN_CHARGE = 0.15;      // Minimum to trigger firework (lower threshold)

                this.leftHand = { charging: false, charge: 0, wasPinching: false };
                this.rightHand = { charging: false, charge: 0, wasPinching: false };
            }

            calculatePinchDistance(landmarks) {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                const dx = thumbTip.x - indexTip.x;
                const dy = thumbTip.y - indexTip.y;
                const dz = thumbTip.z - indexTip.z;
                
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }

            getPinchPosition(landmarks) {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                return {
                    x: (thumbTip.x + indexTip.x) / 2,
                    y: (thumbTip.y + indexTip.y) / 2,
                    z: (thumbTip.z + indexTip.z) / 2
                };
            }

            update(handsData) {
                const events = [];

                // Reset tracking for hands not detected
                let leftDetected = false;
                let rightDetected = false;

                if (handsData && handsData.multiHandLandmarks) {
                    for (let i = 0; i < handsData.multiHandLandmarks.length; i++) {
                        const landmarks = handsData.multiHandLandmarks[i];
                        
                        // Use wrist position to determine left/right instead of unreliable handedness
                        // In mirrored video: actual left hand appears on right side (higher x)
                        // Wrist is landmark 0
                        const wristX = landmarks[0].x;
                        const isLeftHand = wristX > 0.5; // Right side of video = your left hand
                        
                        const handState = isLeftHand ? this.leftHand : this.rightHand;
                        
                        if (isLeftHand) leftDetected = true;
                        else rightDetected = true;

                        const pinchDistance = this.calculatePinchDistance(landmarks);
                        const isPinching = pinchDistance < this.PINCH_THRESHOLD;

                        if (isPinching) {
                            // Charging
                            handState.charging = true;
                            handState.charge = Math.min(1, handState.charge + this.CHARGE_RATE);
                        } else if (handState.wasPinching && handState.charge >= this.MIN_CHARGE) {
                            // Released with enough charge - fire!
                            events.push({
                                type: 'firework',
                                hand: isLeftHand ? 'left' : 'right',
                                position: this.getPinchPosition(landmarks),
                                charge: handState.charge,
                                landmarks: landmarks
                            });
                            handState.charge = 0;
                            handState.charging = false;
                        } else {
                            // Not pinching, decay charge
                            handState.charge = Math.max(0, handState.charge - this.CHARGE_RATE * 0.5);
                            handState.charging = false;
                        }

                        handState.wasPinching = isPinching;
                    }
                }

                // Reset hands that are not detected
                if (!leftDetected) {
                    this.leftHand.charging = false;
                    this.leftHand.charge = 0;
                    this.leftHand.wasPinching = false;
                }
                if (!rightDetected) {
                    this.rightHand.charging = false;
                    this.rightHand.charge = 0;
                    this.rightHand.wasPinching = false;
                }

                return events;
            }

            getHandState(isLeftHand) {
                return isLeftHand ? this.leftHand : this.rightHand;
            }
        }

        // ============================================
        // MAIN APP
        // ============================================
        class GestureFireworksApp {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.startScreen = document.getElementById('start-screen');
                this.uiOverlay = document.getElementById('ui-overlay');
                this.errorMessage = document.getElementById('error-message');

                this.camera = new CameraManager(this.video);
                this.renderer = new Renderer(this.canvas, this.video);
                this.handTracker = new HandTracker();
                this.gestureDetector = new GestureDetector();
                this.particleSystem = new ParticleSystem();
                this.audioManager = new AudioManager();

                this.isRunning = false;
                this.handsData = null;

                // For hints and performance
                this.lastHandsDetectedTime = 0;
                this.showHandsHint = false;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.fps = 60;

                this.setupEventListeners();
            }

            updateUI() {
                const leftStatus = document.getElementById('left-hand-status');
                const rightStatus = document.getElementById('right-hand-status');

                const updateHand = (element, state, label) => {
                    if (state.charging) {
                        const percent = Math.round(state.charge * 100);
                        element.innerHTML = `
                            <span class="status-indicator charging"></span>
                            ${label}: Charging... ${percent}%
                        `;
                    } else {
                        element.innerHTML = `
                            <span class="status-indicator waiting"></span>
                            ${label}: Waiting
                        `;
                    }
                };

                updateHand(leftStatus, this.gestureDetector.leftHand, 'Left hand');
                updateHand(rightStatus, this.gestureDetector.rightHand, 'Right hand');
            }

            checkHandsHint() {
                const now = Date.now();
                const hasHands = this.handsData && 
                                this.handsData.multiHandLandmarks && 
                                this.handsData.multiHandLandmarks.length > 0;

                if (hasHands) {
                    this.lastHandsDetectedTime = now;
                    this.showHandsHint = false;
                } else if (now - this.lastHandsDetectedTime > 3000) {
                    this.showHandsHint = true;
                }
            }

            setupEventListeners() {
                this.startScreen.addEventListener('click', () => this.start());
                window.addEventListener('resize', () => this.renderer.resize());
            }

            async start() {
                this.startScreen.classList.add('hidden');

                // Initialize audio (requires user interaction)
                await this.audioManager.initialize();

                // Initialize hand tracker
                await this.handTracker.initialize();

                this.handTracker.onResults((results) => {
                    this.handsData = results;
                });

                const success = await this.camera.start();
                if (!success) {
                    this.errorMessage.classList.add('visible');
                    return;
                }

                this.renderer.resize();
                this.uiOverlay.classList.add('visible');
                this.isRunning = true;
                this.lastHandsDetectedTime = Date.now();
                this.loop();
            }

            async loop() {
                if (!this.isRunning) return;

                // FPS tracking
                this.frameCount++;
                const now = Date.now();
                if (now - this.lastFpsUpdate > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    // Reduce particles if performance is poor
                    if (this.fps < 30) {
                        this.particleSystem.maxParticles = Math.max(200, this.particleSystem.maxParticles - 50);
                    }
                }

                // Send frame to hand tracker
                await this.handTracker.detectHands(this.video);

                // Update gesture detection
                const events = this.gestureDetector.update(this.handsData);

                // Handle firework events
                for (const event of events) {
                    if (event.type === 'firework') {
                        const canvasPos = this.renderer.convertLandmarkToCanvas(event.position);
                        this.particleSystem.createFirework(canvasPos.x, canvasPos.y, event.charge);
                        this.audioManager.playExplosion(event.charge);
                    }
                }

                // Update particles
                this.particleSystem.update();

                this.renderer.clear();
                this.renderer.drawVideo();

                // Draw hand skeletons with charge effect
                if (this.handsData && this.handsData.multiHandLandmarks) {
                    for (let i = 0; i < this.handsData.multiHandLandmarks.length; i++) {
                        const landmarks = this.handsData.multiHandLandmarks[i];
                        
                        // Use position-based detection (same as gesture detector)
                        const wristX = landmarks[0].x;
                        const isLeftHand = wristX > 0.5;
                        
                        const handState = this.gestureDetector.getHandState(isLeftHand);
                        const chargePercent = handState.charge * 100;
                        
                        this.renderer.drawHandSkeleton(landmarks, isLeftHand, chargePercent);
                        this.renderer.drawPinchIndicator(
                            landmarks[4],
                            landmarks[8],
                            handState.charging
                        );
                    }
                }

                // Draw particles on top
                this.renderer.drawParticles(this.particleSystem);

                // Update UI
                this.updateUI();

                // Check and show hands hint
                this.checkHandsHint();
                if (this.showHandsHint) {
                    this.renderer.drawHint('ðŸ‘‹ Show your hands to the camera');
                }

                // Debug info at bottom of screen
                this.renderer.drawDebugInfo(this.handsData);

                requestAnimationFrame(() => this.loop());
            }
        }

        // Initialize app
        const app = new GestureFireworksApp();
    </script>
</body>
</html>
